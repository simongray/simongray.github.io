<!doctype html>
<html><head><title>Clojure: the Lisp that wants to spread</title><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=CeUM4np2c42DV49nanp55dUBOR20c69GjY-7ZjrNdPo');ol{margin:0;padding:0}table td,table th{padding:0}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Source Serif Pro";font-style:normal}.c8{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;}.c7{color:#000000;text-decoration:none;vertical-align:baseline;font-size:20pt;font-style:normal}.c6{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c9{background-color:#ffffff;width:800px;padding:72pt 72pt 72pt 72pt}.c4{font-weight:400;font-family:"Source Serif Pro"}.c3{color:inherit;text-decoration:inherit}.c5{font-style:italic}.c2{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c9"><h1 class="c8" id="h.yvn7b1z1alam"><span class="c4 c7">Clojure: the Lisp that wants to spread</span></h1><p class="c0"><span class="c1">From its humble beginnings, Clojure was always meant to be a &ldquo;hosted&rdquo; language. It is important to note that while the Clojure of today is definitely a tightly integrated JVM (Java Virtual Machine) language, there were always multiple implementations of Clojure.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c4">The language was consciously designed with its host abstracted away, apart from the host-specific functions in the java namespace and in glimpses of Java interop code. The same held for the </span><span class="c6 c4"><a class="c3" href="https://github.com/clojure/clojure-clr">CLR implementation of Clojure</a></span><span class="c1">&nbsp;for the .NET Common Language Runtime, released concurrently, with its very similar-looking interop code.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">Interestingly, Rich Hickey made an implementation of Clojure in Common Lisp too, but abandoned it prior to the public announcement of Clojure.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">Later, ClojureScript managed to do the same, but with a js namespace rather than a java one. The interop code also looks similar, though the js namespace is much more commonly referenced than any of the java ones, as everything in JavaScript derives from one big namespace (as opposed to discrete classes in discrete modules).</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">The decision to not try to entirely abstract the host away as some other languages do (Java for example, with respect to operating systems) has not in any way hindered the ability of different Clojure implementations to share code between them. At the same time, the different Clojure implementations retain the same level of access to the underlying machine that the languages whose runtimes they leech off (Java, C#, JavaScript) do.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">That makes Clojure powerful.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c4">Clojure is a well-designed language and, crucially, a </span><span class="c4 c5">newer</span><span class="c4">&nbsp;language with many of the past sins of older languages confidently thrown out (ubiquitous mutability, OOP and typing boilerplate) and great new things added in. It&rsquo;s both a conservatively scoped </span><span class="c4 c5">and</span><span class="c1">&nbsp;a fresh take on a programming language. That is great in itself, but to get from well-thought out to powerful, you need to multiply with something else: reach. Clojure is designed to reach beyond a single runtime, while being able to interoperate with its many implementations that constantly spread into different runtimes.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">There&rsquo;s always a little host-specific code in a host namespace. Always the ability to interoperate fully with the host code.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c4">Nowadays, several different unofficial Clojure ports exist for other runtimes: </span><span class="c6 c4"><a class="c3" href="https://github.com/clojerl/clojerl">Clojerl</a></span><span class="c4">&nbsp;on BEAM (the Erlang virtual machine) or </span><span class="c6 c4"><a class="c3" href="https://github.com/candid82/joker">Joker</a></span><span class="c4">&nbsp;(written in Go). Common Lisp has also seen multiple attempts to get Clojure running: </span><span class="c6 c4"><a class="c3" href="https://github.com/joinr/clclojure">clclojure</a></span><span class="c4">&nbsp;and </span><span class="c6 c4"><a class="c3" href="https://github.com/ruricolist/cloture">cloture</a></span><span class="c4">. Inspired-by languages include </span><span class="c6 c4"><a class="c3" href="https://github.com/hylang/hy">Hy</a></span><span class="c4">&nbsp;or </span><span class="c6 c4"><a class="c3" href="https://github.com/pixie-lang/pixie">Pixie</a></span><span class="c4">&nbsp;(for Python); or </span><span class="c6 c4"><a class="c3" href="https://github.com/nakkaya/ferret">Ferret</a></span><span class="c1">&nbsp;that compiles down to C++. Subsets of Clojure also exist in smaller invocations, such as several different implementations integrating Clojure with shell scripts.</span></p><p class="c0"><span class="c1">These are certainly interesting, but lie somewhat evenly spread on a spectrum of how fully-implemented they are.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c4">Clojure CLR, I have a feeling, is mostly used to makes games using </span><span class="c6 c4"><a class="c3" href="https://github.com/arcadia-unity">Arcadia</a></span><span class="c4">&nbsp;(integration with the Unity game engine) and Arcadia is in fact creating its own competing Clojure compiler, </span><span class="c6 c4"><a class="c3" href="https://github.com/nasser/magic">MAGIC</a></span><span class="c1">. This is great for Clojure game development and less great for other things, but obviously reflects .NET reach more than it really does Clojure CLR as a language.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">The big stars are still ClojureScript and Clojure on the JVM. ClojureScript has now spread beyond its initial borders into the confines of Node.js and a bunch of other JavaScript runtimes, but the biggest host platform is still by far the browser. And it&rsquo;s excellent at that.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">These days it&rsquo;s common for Clojure libraries to either have a common Clojure implementation (facilitated with .cljc files) or alternative implementations of the library for both Clojure and ClojureScript. That&rsquo;s a 2x multiplier you can apply just for the healthy library ecosystem that has been created for these two languages.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c4">At the same time, the fact that Clojure&rsquo;s primitives are easily serialisable led to using EDN (Extensible Data Notation) as the format of exchange between frontend and backend. This is similar to the relationship that JavaScript has with JSON. Since then, the </span><span class="c6 c4"><a class="c3" href="https://github.com/cognitect/transit-format">Transit</a></span><span class="c1">&nbsp;library has made that process even simpler by setting up a direct data pipe between ClojureScript and Clojure.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">The way the languages are integrated today, Clojure developers doing full-stack development don&rsquo;t really have to think about data serialisation/deserialisation. Writing code for frontend and backend differ mostly just in the way that the different implementations access the host platform. The functional aspects of Clojure, especially the immutability and focus on referential transparency, ensure that source code is mostly split into chunks of highly portable code, with the host-interop conveniently put aside in its own sections. You can move code between frontend and backend at your leisure.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">So, the 2x multiplier awarded earlier for reach should really be incremented some more to reflect all of the code we don&rsquo;t have to write &ndash; and more importantly: don&rsquo;t have to think about. This is how the design of Clojure as a hosted language makes it more powerful.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">Clojure&rsquo;s main Achilles&rsquo; heel right now, with respect to reach, is its relatively slow application start-up time. This is the primary reason that Clojure hasn&rsquo;t taken off as a language for Android development and for making desktop apps. This also makes Clojure slightly less suitable for command-line utilities, reducing its reach for writing these on the desktop OS platforms. And of course, Java never really took off as a language for developing desktop apps, other than GUIs made for in-house corporate software and research apps. And Minecraft.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c4">That has not mattered as much as it may have, as the community has long been using ClojureScript for both </span><span class="c6 c4"><a class="c3" href="https://cljsrn.org/">app development</a></span><span class="c4">&nbsp;and writing shell scripts. Now we are able to leverage the </span><span class="c4 c6"><a class="c3" href="https://www.graalvm.org/docs/reference-manual/native-image/">GraalVM Native Image</a></span><span class="c1">&nbsp;compiler too. By transpiling JVM bytecode into machine code, Clojure has inadvertently spread to yet another platform: native code.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c4">And most recently, we have even been getting direct interop with Python from JVM Clojure using </span><span class="c6 c4"><a class="c3" href="https://github.com/clj-python/libpython-clj">libpython-clj</a></span><span class="c4">&nbsp;and interop with R through </span><span class="c6 c4"><a class="c3" href="https://github.com/scicloj/clojisr">clojisr</a></span><span class="c4">.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">This kind of reach of a single language is not as common among programming languages as you may think.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">Clojure is (slowly) eating the world. Honestly, we should be thankful that the language continues to grow despite being fairly unorthodox, compared with the current norm of typed functional languages and the massive sea of object-oriented code that&rsquo;s out there. &nbsp;It&rsquo;s also the odd child in the Lisp family with its functional, data-driven, and interop-heavy approach to programming.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">And we can&rsquo;t forget the terrible sin of putting starting parentheses in front of function names rather than after them!</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c1">Clojure is unorthodox. It exists in a world dominated by primarily object-oriented, imperative languages. But it is delivering lots of value already while constantly increasing its reach and benefiting from it in return.</span></p><p class="c0 c2"><span class="c1"></span></p><p class="c0"><span class="c4">~ </span><span class="c6 c4"><a class="c3" href="https://github.com/simongray">Simon Gray</a></span></p><p class="c0 c2"><span class="c1"></span></p></body></html>